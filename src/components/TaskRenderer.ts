import {
  App,
  Component,
  MarkdownRenderer,
  TFile,
} from "obsidian";
import { TaskItem } from "../types/TaskItem";
import { appendSnoozeButtonIfEligible } from "./TaskButtons";

// Shared tree renderer (used by all sections)
export function renderTaskTree(
  tasks: TaskItem[],
  container: HTMLElement,
  app: App,
  depth: number,
  isRoot: boolean,
  sectionType: string // Kept for potential future use, but sections can override
) {
  // Skip if no tasks
  if (tasks.length === 0) return;

  // Create container UL for this level; rely on Obsidian's task-list styles
  const taskList = container.createEl("ul", {
    cls: "agile-dashboard contains-task-list"
  });

  tasks.forEach((task) => {
    // Skip truly blank tasks
    if (
      !task.text?.trim() &&
      !task.visual?.trim() &&
      (!task.children || task.children.length === 0)
    )
      return;

    // Create a temporary div to hold the rendered markdown (we'll extract the LI Obsidian generates)
    const tempEl = document.createElement("div");
    const renderComponent = new Component();
    MarkdownRenderer.renderMarkdown(
      (task.visual || task.text || "").trim(),
      tempEl,
      task.link?.path || "",
      renderComponent
    );
    renderComponent.load();

    // Prefer the LI generated by MarkdownRenderer to preserve Obsidian classes/attributes
    const firstEl = tempEl.firstElementChild as HTMLElement | null;
    let taskItemEl: HTMLElement;

    if (
      firstEl?.tagName.toLowerCase() === "ul" &&
      firstEl.children.length === 1 &&
      (firstEl.firstElementChild as HTMLElement | null)?.tagName.toLowerCase() === "li"
    ) {
      taskItemEl = firstEl.firstElementChild as HTMLElement;
      taskList.appendChild(taskItemEl);
    } else {
      // Fallback: create our own LI and mark it as a task-list-item for CSS compatibility
      taskItemEl = taskList.createEl("li", { cls: "task-list-item" });
      while (tempEl.firstChild) {
        taskItemEl.appendChild(tempEl.firstChild);
      }
    }

    if (task.annotated) {
      taskItemEl.addClass("annotated-task");
    }

    // Attach snooze button if eligible for this section
    try {
      appendSnoozeButtonIfEligible(task, taskItemEl, sectionType, app);
    } catch (e) {
      console.error("Failed to attach snooze button", e);
    }

    // Recurse for children: Create a new ul directly inside this li
    if (task.children && task.children.length > 0) {
      renderTaskTree(
        task.children,
        taskItemEl, // Recurse into this li
        app,
        depth + 1,
        false,
        sectionType
      );
    }
  });
}

// Shared status change handler (used by sections that need checkboxes/interactivity)
export const handleStatusChange = async (
  task: TaskItem,
  app: App,
  isCancel = false
): Promise<void> => {
  try {
    const currentStatus = task.status || " ";
    let newStatus = currentStatus;

    if (isCancel) {
      newStatus = "-";
    } else {
      if (currentStatus === " ") newStatus = "/";
      else if (currentStatus === "/" || currentStatus === "d")
        newStatus = "x";
      else return;
    }

    const file = app.vault.getAbstractFileByPath(task.link.path) as TFile;
    if (!file) throw new Error(`File not found: ${task.link.path}`);

    const content = await app.vault.read(file);
    const escapedTaskText = task.text.replace(
      /[.*+?^${}()|[\]\\]/g,
      "\\$&"
    );

    const taskLineRegex = new RegExp(
      `^(\\s*[-*]\\s*)\\[\\s*${currentStatus}\\s*\\]\\s*(${escapedTaskText})\\s*$`,
      "gm"
    );

    const newContent = content.replace(
      taskLineRegex,
      (match, prefix, textPart) => {
        let updatedLine = `${prefix}[${newStatus}] ${textPart}`;
        if (newStatus === "x" && !isCancel) {
          const today = new Date().toISOString().split("T")[0];
          const completionMarker = ` âœ… ${today}`;
          if (!/\s$/.test(updatedLine)) updatedLine += " ";
          updatedLine += completionMarker;
        }
        return updatedLine;
      }
    );

    if (newContent === content)
      throw new Error("No matching task line found");

    await app.vault.modify(file, newContent);
  } catch (error) {
    console.error("Error updating task status:", error);
  }
};
