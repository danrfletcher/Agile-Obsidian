import { App, Component, MarkdownRenderer, TFile } from "obsidian";
import { TaskItem } from "src/features/tasks/task-item";
import {
	appendSnoozeButtonIfEligible,
	hideTaskAndCollapseAncestors,
} from "./task-buttons";
import { updateAssigneeAndPropagate } from "src/features/task-assignment/assignment-utils";

// Helpers to control checkbox interactivity per section and hierarchy level
function isLeaf(task: TaskItem): boolean {
	return !task.children || task.children.length === 0;
}

function shouldEnableCheckbox(
	sectionType: string,
	depth: number,
	task: TaskItem,
	isRoot: boolean
): boolean {
	const s = (sectionType || "").toLowerCase();
	const leaf = isLeaf(task);

	// Initiatives: allow all levels
	if (s.includes("initiative")) return true;

	// Objectives: allow only the real top-level OKR (root of section) or lowest-level linked items.
	if (s.includes("objective")) return (isRoot && depth === 0) || leaf;

	// Tasks, Stories, Epics, Priorities, Responsibilities: only lowest-level (leaf) tasks
	if (
		s.includes("task") ||
		s.includes("story") ||
		s.includes("epic") ||
		s.includes("priorit") ||
		s.includes("responsibil")
	) {
		return leaf;
	}

	// Default: allow
	return true;
}

let assignmentEventListenerAttached = false;

function ensureAssignmentEventListener(app: App) {
	if (assignmentEventListenerAttached) return;
	assignmentEventListenerAttached = true;

	window.addEventListener(
		"agile:request-assign-propagate" as any,
		async (ev: Event) => {
			try {
				const ce = ev as CustomEvent<any>;
				const detail = (ce && (ce as any).detail) || {};
				const uid = detail?.uid;
				const newAlias = detail?.newAlias;
				if (
					typeof uid === "string" &&
					typeof newAlias === "string" &&
					uid
				) {
					const filePath = uid.split(":")[0] || "";
					if (filePath) {
						window.dispatchEvent(
							new CustomEvent(
								"agile:prepare-optimistic-file-change",
								{
									detail: { filePath },
								}
							)
						);
					}
					await updateAssigneeAndPropagate(app, uid, newAlias);
					if (filePath) {
						window.dispatchEvent(
							new CustomEvent("agile:assignment-changed", {
								detail: { uid, filePath, newAlias },
							})
						);
					}
				}
			} catch {}
		}
	);
}

function annotateAssigneeMarks(
	liEl: HTMLElement,
	uid: string,
	filePath: string
) {
	const marks = liEl.querySelectorAll("mark");
	marks.forEach((m) => {
		const el = m as HTMLElement;
		const cls = (el.getAttribute("class") || "").toLowerCase();
		// Mark must have an active/inactive-<alias> class
		if (
			!/(^|\s)(?:active|inactive)-[a-z0-9-]+(\s|$)/i.test(" " + cls + " ")
		)
			return;
		// And contain a 👋 strong (assignee, not delegate)
		const strong = el.querySelector("strong");
		if (!strong || !/^\s*👋/u.test(strong.textContent || "")) return;
		el.setAttribute("data-task-uid", uid);
		if (filePath) el.setAttribute("data-file-path", filePath);
	});
}

// Shared tree renderer (used by all sections)
export function renderTaskTree(
	tasks: TaskItem[],
	container: HTMLElement,
	app: App,
	depth: number,
	isRoot: boolean,
	sectionType: string // Kept for potential future use, but sections can override
) {
	ensureAssignmentEventListener(app);

	// Skip if no tasks
	if (tasks.length === 0) return;

	// Create container UL for this level; rely on Obsidian's task-list styles
	const taskList = container.createEl("ul", {
		cls: "agile-dashboard contains-task-list",
	});

	tasks.forEach((task) => {
		// Skip truly blank tasks
		if (
			!task.text?.trim() &&
			!task.visual?.trim() &&
			(!task.children || task.children.length === 0)
		)
			return;

		// Create a temporary div to hold the rendered markdown (we'll extract the LI Obsidian generates)
		const tempEl = document.createElement("div");
		const renderComponent = new Component();
		MarkdownRenderer.renderMarkdown(
			(task.visual || task.text || "").trim(),
			tempEl,
			task.link?.path || "",
			renderComponent
		);
		renderComponent.load();

		// Prefer the LI generated by MarkdownRenderer to preserve Obsidian classes/attributes
		const firstEl = tempEl.firstElementChild as HTMLElement | null;
		let taskItemEl: HTMLElement;

		if (
			firstEl?.tagName.toLowerCase() === "ul" &&
			firstEl.children.length === 1 &&
			(
				firstEl.firstElementChild as HTMLElement | null
			)?.tagName.toLowerCase() === "li"
		) {
			taskItemEl = firstEl.firstElementChild as HTMLElement;
			taskList.appendChild(taskItemEl);
		} else {
			// Fallback: create our own LI and mark it as a task-list-item for CSS compatibility
			taskItemEl = taskList.createEl("li", { cls: "task-list-item" });
			while (tempEl.firstChild) {
				taskItemEl.appendChild(tempEl.firstChild);
			}
		}

		if (task.annotated) {
			taskItemEl.addClass("annotated-task");
		}

		// Tag LI and assignee marks with identifiers so external handlers can target the correct task/line
		if (task._uniqueId) {
			taskItemEl.setAttribute("data-task-uid", task._uniqueId);
		}
		const filePath = task.link?.path || "";
		if (filePath) {
			taskItemEl.setAttribute("data-file-path", filePath);
		}
		try {
			annotateAssigneeMarks(taskItemEl, task._uniqueId || "", filePath);
		} catch (e) {}

		// Attach snooze button if eligible for this section
		try {
			appendSnoozeButtonIfEligible(task, taskItemEl, sectionType, app);
		} catch (e) {}

		// Wire up checkbox click and long-press to update status
		const checkbox = taskItemEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;
		if (checkbox) {
			const interactive = shouldEnableCheckbox(
				sectionType,
				depth,
				task,
				isRoot
			);
			if (!interactive) {
				// Disable interaction (including label toggles) while preserving visual state
				checkbox.disabled = true;
				checkbox.tabIndex = -1;
				checkbox.setAttribute("aria-disabled", "true");
				(checkbox as HTMLElement).style.pointerEvents = "none";
			} else {
				let pressTimer: number | null = null;
				let longPressed = false;
				const LONG_PRESS_MS = 500;

				let initialChecked = checkbox.checked;
				let isUpdating = false;

				const performUpdate = async (
					cancel: boolean,
					source: string
				) => {
					if (isUpdating) {
						return;
					}
					isUpdating = true;
					try {
						const result = await handleStatusChange(
							task,
							taskItemEl,
							app,
							cancel
						);
						if (result === "/") {
							// Re-render just this task's inline content so the status icon updates
							rerenderTaskInline(
								task,
								taskItemEl,
								app,
								sectionType,
								result,
								isRoot,
								depth
							);
						} else if (result === "x") {
							// Reflect checked UI for completed tasks (will be hidden shortly if applicable)
							checkbox.checked = true;
							initialChecked = true;
						}
					} catch (e) {
					} finally {
						isUpdating = false;
					}
				};

				// Prevent native toggle; we control the state via note updates and optimistic UI.
				checkbox.addEventListener("change", (ev) => {
					ev.preventDefault();
					// @ts-ignore
					ev.stopImmediatePropagation?.();
					checkbox.checked = initialChecked;
				});

				// Keyboard accessibility: Space/Enter toggles like click
				checkbox.addEventListener("keydown", async (ev) => {
					const key = (ev as KeyboardEvent).key;
					if (key === " " || key === "Enter") {
						ev.preventDefault();
						await performUpdate(false, "keydown");
					}
				});

				const clearTimer = () => {
					if (pressTimer !== null) {
						window.clearTimeout(pressTimer);
						pressTimer = null;
					}
				};

				const onPressStart = (ev: Event) => {
					longPressed = false;
					clearTimer();
					pressTimer = window.setTimeout(async () => {
						longPressed = true;
						// Long press => cancel
						await performUpdate(true, "longpress");
					}, LONG_PRESS_MS);
				};

				const onPressEnd = () => {
					clearTimer();
				};

				checkbox.addEventListener("mousedown", onPressStart);
				checkbox.addEventListener("touchstart", onPressStart, {
					passive: true,
				});
				checkbox.addEventListener("mouseup", onPressEnd);
				checkbox.addEventListener("mouseleave", onPressEnd);
				checkbox.addEventListener("touchend", onPressEnd);
				checkbox.addEventListener("touchcancel", onPressEnd);

				checkbox.addEventListener("click", async (ev) => {
					ev.preventDefault();
					ev.stopPropagation();
					if (longPressed) {
						// Already handled by long-press
						longPressed = false;
						return;
					}
					await performUpdate(false, "click");
				});
			}
		}

		// Recurse for children: Create a new ul directly inside this li
		if (task.children && task.children.length > 0) {
			renderTaskTree(
				task.children,
				taskItemEl, // Recurse into this li
				app,
				depth + 1,
				false,
				sectionType
			);
		}
	});
}

/**
 * Re-render only the inline content (checkbox + line text) for a task's <li> to refresh status icon,
 * preserving any nested child <ul>, then reattach snooze button and re-wire interactions.
 */
function rerenderTaskInline(
	task: TaskItem,
	liEl: HTMLElement,
	app: App,
	sectionType: string,
	newStatus: string,
	isRoot: boolean,
	depth: number
): void {
	try {
		// Preserve existing child lists (subtasks)
		const childLists = Array.from(
			liEl.querySelectorAll(":scope > ul")
		) as HTMLElement[];

		// Build updated markdown line for this task
		let lineMd = (task.visual || task.text || "").trim();

		// Update or inject the task status marker
		if (/^\s*[-*]\s*\[\s*.\s*\]/.test(lineMd)) {
			lineMd = lineMd.replace(
				/^(\s*[-*]\s*\[\s*)(.)(\s*\])/,
				`$1${newStatus}$3`
			);
		} else {
			lineMd = `- [${newStatus}] ${lineMd}`;
		}

		// Remove any completion/cancel markers for non-terminal statuses like "/"
		if (newStatus === "/") {
			lineMd = lineMd
				.replace(/\s*(✅|❌)\s+\d{4}-\d{2}-\d{2}\b/g, "")
				.trimEnd();
		}

		// Clear current inline content
		liEl.innerHTML = "";

		// Render updated line using Obsidian's renderer
		const tempEl = document.createElement("div");
		const renderComponent = new Component();
		MarkdownRenderer.renderMarkdown(
			lineMd,
			tempEl,
			task.link?.path || "",
			renderComponent
		);
		renderComponent.load();

		// Extract the generated LI contents (UL > LI) and sync attributes so CSS status icons stay correct
		const firstEl = tempEl.firstElementChild as HTMLElement | null;
		if (
			firstEl?.tagName.toLowerCase() === "ul" &&
			firstEl.children.length === 1 &&
			(
				firstEl.firstElementChild as HTMLElement | null
			)?.tagName.toLowerCase() === "li"
		) {
			const sourceLi = firstEl.firstElementChild as HTMLElement;

			// Preserve custom class if present
			const hadAnnotated = liEl.classList.contains("annotated-task");

			// Sync key attributes/classes from sourceLi onto our existing LI
			const dataTask = sourceLi.getAttribute("data-task");
			if (dataTask !== null) liEl.setAttribute("data-task", dataTask);
			else liEl.removeAttribute("data-task");

			const role = sourceLi.getAttribute("role");
			if (role !== null) liEl.setAttribute("role", role);
			else liEl.removeAttribute("role");

			const ariaChecked = sourceLi.getAttribute("aria-checked");
			if (ariaChecked !== null)
				liEl.setAttribute("aria-checked", ariaChecked);
			else liEl.removeAttribute("aria-checked");

			// Replace class list with the freshly rendered one
			liEl.className = sourceLi.className;
			if (hadAnnotated) liEl.classList.add("annotated-task");

			// Move over the newly rendered inline content
			while (sourceLi.firstChild) {
				liEl.appendChild(sourceLi.firstChild);
			}
		} else {
			// Fallback: move all rendered nodes and best-effort attribute updates
			while (tempEl.firstChild) {
				liEl.appendChild(tempEl.firstChild);
			}
			// Ensure attributes reflect the new status so CSS can render correctly
			liEl.classList.add("task-list-item");
			if (newStatus === "x") liEl.classList.add("is-checked");
			else liEl.classList.remove("is-checked");
			liEl.setAttribute("data-task", newStatus);
		}

		// Ensure checkbox element carries the correct data-task for CSS snippets
		const inputEl = liEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;
		if (inputEl) {
			inputEl.setAttribute("data-task", newStatus);
		}

		// Re-attach preserved child lists (subtasks)
		childLists.forEach((ul) => liEl.appendChild(ul));

		// Re-attach snooze button if eligible
		try {
			appendSnoozeButtonIfEligible(task, liEl, sectionType, app);
		} catch (e) {}

		// Re-wire checkbox interactions for the newly rendered checkbox
		const checkbox = liEl.querySelector(
			'input[type="checkbox"]'
		) as HTMLInputElement | null;

		if (checkbox) {
			const interactive = shouldEnableCheckbox(
				sectionType,
				depth,
				task,
				isRoot
			);
			if (!interactive) {
				checkbox.disabled = true;
				checkbox.tabIndex = -1;
				checkbox.setAttribute("aria-disabled", "true");
				(checkbox as HTMLElement).style.pointerEvents = "none";
			} else {
				let pressTimer: number | null = null;
				let longPressed = false;
				const LONG_PRESS_MS = 500;

				let initialChecked = checkbox.checked;
				let isUpdating = false;

				const performUpdate = async (
					cancel: boolean,
					source: string
				) => {
					if (isUpdating) {
						return;
					}
					isUpdating = true;
					try {
						const result = await handleStatusChange(
							task,
							liEl,
							app,
							cancel
						);
						if (result === "/") {
							rerenderTaskInline(
								task,
								liEl,
								app,
								sectionType,
								result,
								isRoot,
								depth
							);
						} else if (result === "x") {
							checkbox.checked = true;
							initialChecked = true;
						}
					} catch (e) {
					} finally {
						isUpdating = false;
					}
				};

				// Prevent native toggle; we control the state via note updates and optimistic UI.
				checkbox.addEventListener("change", (ev) => {
					ev.preventDefault();
					// @ts-ignore
					ev.stopImmediatePropagation?.();
					checkbox.checked = initialChecked;
				});

				// Keyboard accessibility: Space/Enter toggles like click
				checkbox.addEventListener("keydown", async (ev) => {
					const key = (ev as KeyboardEvent).key;
					if (key === " " || key === "Enter") {
						ev.preventDefault();
						await performUpdate(false, "keydown");
					}
				});

				const clearTimer = () => {
					if (pressTimer !== null) {
						window.clearTimeout(pressTimer);
						pressTimer = null;
					}
				};

				const onPressStart = (ev: Event) => {
					longPressed = false;
					clearTimer();
					pressTimer = window.setTimeout(async () => {
						longPressed = true;
						await performUpdate(true, "longpress");
					}, LONG_PRESS_MS);
				};

				const onPressEnd = () => {
					clearTimer();
				};

				checkbox.addEventListener("mousedown", onPressStart);
				checkbox.addEventListener("touchstart", onPressStart, {
					passive: true,
				});
				checkbox.addEventListener("mouseup", onPressEnd);
				checkbox.addEventListener("mouseleave", onPressEnd);
				checkbox.addEventListener("touchend", onPressEnd);
				checkbox.addEventListener("touchcancel", onPressEnd);

				checkbox.addEventListener("click", async (ev) => {
					ev.preventDefault();
					ev.stopPropagation();
					if (longPressed) {
						longPressed = false;
						return;
					}
					await performUpdate(false, "click");
				});
			}
		}
	} catch (e) {}
}

// Shared status change handler (used by sections that need checkboxes/interactivity)
export const handleStatusChange = async (
	task: TaskItem,
	liEl: HTMLElement,
	app: App,
	isCancel = false
): Promise<string | null> => {
	try {
		const filePath = task.link?.path;
		if (!filePath) throw new Error("Missing task.link.path");

		const file = app.vault.getAbstractFileByPath(filePath) as TFile;
		if (!file) throw new Error(`File not found: ${filePath}`);

		// Let the dashboard know we're doing an optimistic file change so it can suppress full refresh
		window.dispatchEvent(
			new CustomEvent("agile:prepare-optimistic-file-change", {
				detail: { filePath },
			})
		);

		const content = await app.vault.read(file);
		const lines = content.split(/\r?\n/);

		// Determine current status and correct line index for this task
		let effectiveStatus = (task.status ?? " ").trim() || " ";
		let targetLineIndex = -1;

		const parseStatusFromLine = (line: string): string | null => {
			const m = line.match(/^\s*[-*]\s*\[\s*(.)\s*\]/);
			return m ? m[1] : null;
		};

		// Normalizer to compare task text with file line text, ignoring completion/cancel markers and extra spaces
		const normalize = (s: string) =>
			(s || "")
				.replace(/\s*(✅|❌)\s+\d{4}-\d{2}-\d{2}\b/g, "")
				.replace(/\s+/g, " ")
				.trim();

		const getLineRestNormalized = (line: string): string | null => {
			const m = line.match(/^\s*[-*]\s*\[\s*.\s*\]\s*(.*)$/);
			return m ? normalize(m[1]) : null;
		};

		const targetTextNorm = normalize(
			(task.text || task.visual || "").trim()
		);

		// 1) Try to use the reported line index (and neighbors) but validate by text
		const baseIdx = typeof task.line === "number" ? task.line : -1;
		const candidates = [baseIdx, baseIdx - 1, baseIdx + 1].filter(
			(i) => i >= 0 && i < lines.length
		);

		for (const i of candidates) {
			const rest = getLineRestNormalized(lines[i]);
			if (!rest) continue;
			if (
				rest === targetTextNorm ||
				rest.startsWith(targetTextNorm) ||
				targetTextNorm.startsWith(rest)
			) {
				targetLineIndex = i;
				const parsed = parseStatusFromLine(lines[i]);
				if (parsed) effectiveStatus = parsed;
				break;
			}
		}

		// 2) If still not found, scan the file for an exact normalized match, then a startsWith match
		if (targetLineIndex === -1 && targetTextNorm) {
			for (let i = 0; i < lines.length; i++) {
				const rest = getLineRestNormalized(lines[i]);
				if (rest && rest === targetTextNorm) {
					targetLineIndex = i;
					const parsed = parseStatusFromLine(lines[i]);
					if (parsed) effectiveStatus = parsed;
					break;
				}
			}
			if (targetLineIndex === -1) {
				for (let i = 0; i < lines.length; i++) {
					const rest = getLineRestNormalized(lines[i]);
					if (rest && rest.startsWith(targetTextNorm)) {
						targetLineIndex = i;
						const parsed = parseStatusFromLine(lines[i]);
						if (parsed) effectiveStatus = parsed;
						break;
					}
				}
			}
		}

		const newStatus = isCancel ? "-" : effectiveStatus === "/" ? "x" : "/";

		const today = new Date();
		const yyyy = String(today.getFullYear());
		const mm = String(today.getMonth() + 1).padStart(2, "0");
		const dd = String(today.getDate()).padStart(2, "0");
		const dateStr = `${yyyy}-${mm}-${dd}`;

		const updateLine = (line: string): string => {
			const m = line.match(/^(\s*[-*]\s*\[\s*)(.)(\s*\]\s*)(.*)$/);
			if (!m) return line;

			const prefix = m[1];
			const bracketSuffix = m[3];
			let rest = m[4] ?? "";

			// Remove any existing completion/cancel markers to avoid duplicates
			rest = rest
				.replace(/\s*(✅|❌)\s+\d{4}-\d{2}-\d{2}\b/g, "")
				.trimEnd();

			let updated = `${prefix}${newStatus}${bracketSuffix}${
				rest ? " " + rest : ""
			}`;

			if (newStatus === "x") {
				updated += ` ✅ ${dateStr}`;
			} else if (newStatus === "-") {
				updated += ` ❌ ${dateStr}`;
			}

			return updated;
		};

		let newContent: string | null = null;

		const tryReplaceAtIndex = (idx: number) => {
			if (idx < 0 || idx >= lines.length) return false;
			const originalLine = lines[idx];
			const replaced = updateLine(originalLine);
			if (replaced !== originalLine) {
				lines[idx] = replaced;
				newContent = lines.join("\n");
				return true;
			}
			return false;
		};

		// 1) Try by known line index
		if (targetLineIndex !== -1) {
			tryReplaceAtIndex(targetLineIndex);
		}

		// 2) If not replaced, search for the best-matching task line by normalized text
		if (newContent == null) {
			const targetText = normalize(
				(task.text || task.visual || "").trim()
			);

			if (targetText) {
				// First pass: exact normalized match
				for (let i = 0; i < lines.length; i++) {
					const m = lines[i].match(/^\s*[-*]\s*\[\s*.\s*\]\s*(.*)$/);
					if (!m) continue;
					const rest = normalize(m[1]);
					if (rest === targetText) {
						if (tryReplaceAtIndex(i)) break;
					}
				}

				// Second pass: startsWith normalized match
				if (newContent == null) {
					for (let i = 0; i < lines.length; i++) {
						const m = lines[i].match(
							/^\s*[-*]\s*\[\s*.\s*\]\s*(.*)$/
						);
						if (!m) continue;
						const rest = normalize(m[1]);
						if (rest.startsWith(targetText)) {
							if (tryReplaceAtIndex(i)) break;
						}
					}
				}
			}
		}

		// 3) As a last resort, if we still didn't modify, try a loose regex replace:
		if (newContent == null) {
			const escaped = (task.text || "")
				.trim()
				.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
			if (escaped) {
				const re = new RegExp(
					`^(\\s*[-*]\\s*\\[\\s*).(\\s*\\]\\s*)${escaped}(.*)$`,
					"m"
				);
				newContent = content.replace(re, (match) => updateLine(match));
				if (newContent === content) {
					newContent = null; // no-op; ensure we fail below
				}
			}
		}

		if (!newContent || newContent === content) {
			throw new Error("Unable to update task line");
		}

		await app.vault.modify(file, newContent);

		// Update in-memory task to keep subsequent toggles working without reload
		(task as any).status = newStatus;

		// Optimistic UI: if task completed or cancelled, hide node and collapse ancestors/section if needed
		if (newStatus === "x" || newStatus === "-") {
			try {
				hideTaskAndCollapseAncestors(liEl);
			} catch (e) {}
		}

		return newStatus;
	} catch (error) {
		return null;
	}
};
